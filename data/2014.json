[{"question_id": "Fall2014_1", "topic": "Graphs and DFS", "question_description": "Circle TRUE or FALSE. Do not justify your answers on this problem.\n\n(a) | TRUE | or FALSE: If we perform DFS on an undirected graph, there are no cross edges.\n\n(b) | TRUE] or FALSE: If the DFS tree has no back edges, then there are no cycles in the graph.\n\n(c) | TRUE | or FALSE: Any tree with n vertices is guaranteed to have exactly n - 1 edges.\n\n(d) TRUE or| FALSE |: Suppose G is a directed graph G = (V,E), and define the undirected graph\nG' by G' = (V,E') where E' is the set of edges {u,v} such that (u,v) \u00e2\u02c6\u02c6 E or (v,u) \u00e2\u02c6\u02c6 E. Then,\nif G is not strongly connected, then it's guaranteed that G' is not connected.\n\n(e) TRUE or| FALSE |: If G is a strongly connected directed graph, then there is guaranteed to exist\na vertex such that deleting that vertex leaves you with a graph that is also strongly connected.\n\n(f) TRUE or| FALSE[ Suppose we have a directed acyclic graph (dag) G with at least n - 1 edges\nand where a topological sort yields the vertices v1,...,vn in that order. If we add the edge\n(vn, v1), then the resulting graph is guaranteed to be strongly connected.\n\n(g) TRUE or| FALSE}: Dijkstra's algorithm will always work correctly on any graph that has at\nmost two negative edges.\n\n(h) | TRUE] or FALSE: If an undirected graph with n vertices has k connected components, then it\nmust have at least n - k edges.\n\n(i) TRUE or| FALSE If a graph with integer lengths on the edges (some of them possibly neg-\native) has no negative cycle reachable from s, then Dijkstra's algorithm works correctly for\nfinding the length of the shortest path from s to every other vertex reachable from s.\n\n(j) TRUE or| FALSE} If we have a linear program where all of the coefficients and constants\nin every linear inequality are integers, then the optimum solution to this linear program must\nassign an integer value to every variable.\n\n(k) TRUE or |FALSE|: If we have an undirected graph G = (V,E) where |V| = |E|, then G is\nguaranteed to be a tree.\n\n(l) TRUE or| FALSE}: If G is a graph with positive lengths on the edges, and if all edge lengths\nare distinct, and if s,t are two vertices, then there is a unique shortest path from s to ft.", "answer": "a) FALSE\nb) TRUE\nc) TRUE\nd) TRUE\ne) FALSE\nf) FALSE\ng) TRUE\nh) TRUE\ni) TRUE\nj) TRUE\nk) FALSE\nl) FALSE", "hint": "For each statement, think about the properties of the given graph and the definitions of the terms used in the statement.", "subproblem": []}, {"question_id": "Fall2014_2", "topic": "Strongly Connected Components", "question_description": "Answer the following questions. No need to justify your answer. Use O(-) notation.\n\n(a) What is the asymptotic running time of decomposing a directed graph into strongly connected components, if the graph has n vertices and nlgn edges?\n\n(b) What is the asymptotic running time of Dijkstra's algorithm, on a graph with n vertices and m edges (assuming all edges have non-negative length), if we implement the priority queue with a binary heap?\n\n(c) What is the asymptotic running time of the Bellman-Ford algorithm, on a graph with n vertices and m edges?\n\n(d) What is the asymptotic solution to the recurrence F(n) = 3F(n/2) + 1gn?", "answer": "a) O(nlgn)\nb) O((n + m)lgn)\nc) O(nm)\nd) O(n^2)", "hint": "Think about the operations performed in each algorithm and how they depend on the size of the input.", "subproblem": []}, {"question_id": "Fall2014_3", "topic": "Introduction Big-O Notation and Arithmetic", "question_description": "Answer the following questions, giving a short justification (a sentence or two).\n\n(a) Suppose we have already trained two classifiers. Classifier A is a k-nearest neighbors classifier with a fixed k = 25, using a linear search implementation (not a k-d tree). Classifier B is a random forest classifier with a fixed T = 25 (i.e., 25 decision trees), where each decision tree has depth at most 10. Now we want to know the running time to classify 100 test points. If the number of observations in the training set is very large, which classifier will be faster at this task? In other words, if we consider the asymptotic running time for this task as a function of n, which classifier will have an asymptotically faster running time?", "answer": "Classifier B. The running time of B is fixed regardless of n, whereas the running time of A is proportional to n.", "hint": "Consider the number of operations each classifier needs to perform for each test point.", "subproblem": []}, {"question_id": "Fall2014_4", "topic": "Dynamic Programming", "question_description": "We have a directed graph G = (V,E) with n vertices and m edges and integer lengths on all the edges. Only k of the edges have negative lengths; all the others have non-negative lengths. There are no negative cycles.\n\nYour friend has a clever idea for computing the length of the shortest path from a vertex s to a vertex t. He will construct a new graph G' whose vertices are the endpoints of the negative edges of G, together with s and t. Each edge (u,v) in G' represents the length of the shortest path from u to v in G without using any negative-length edge. He'll use Dijkstra's algorithm to compute each of these lengths. Then, he'll add in all of the negative edges to G', and run Bellman-Ford on the result.\n\nWhat is the asymptotic running time of your friend's algorithm, as a function of n and m and k? Give a short justification (a sentence or two).", "answer": "O(k(n + m)lgn + 4). We do Dijkstra's algorithm 2k times, once for each endpoint of a negative edge, and that takes O((n + m)lgn) time per endpoint; then Bellman-Ford takes O(k^2) time.", "hint": "Think about the number of times each algorithm needs to be run and the running time of each algorithm.", "subproblem": []}, {"question_id": "Fall2014_5", "topic": "Divide-and-Conquer", "question_description": "Given two sorted lists of size m and n, we want to find the kth smallest element in the concatenation of the two lists. Fill in the blanks below so we get an algorithm whose running time is O(lgm + Ign). Assume k < m and k < n.\n\nFind_kth_elem(A[1..m], B[1..n],k):\n1. Let x:=A[|k/2}] and y := B[[k/2]].\n2. If x==y:\n\n3. Return |x\n\n4. If x>y:\n5. Return Find_kth_elem(A|| 1 |.) |&/2] |], Bl] [k/2] + 1]..,&]], | [k/2] )\n6. If x<y:\n7. Return Find_kth_elem(A|| |k/2| + 1}..[&|], B[L1 |.) [&/2] J], | [k/21)\n\nNow, answer the following question. Which algorithm design paradigm does this algorithm best represent?\n\n1. Divide-and-conquer\n\n2. Greedy algorithm\n\n3. Dynamic programming\n4. Linear programming\n\n5. Reduce to network flow\n\n6. None of the above", "answer": "1. Divide-and-conquer", "hint": "Think about the structure of the algorithm and how it breaks down the problem into smaller parts.", "subproblem": []}, {"question_id": "Fall2014_6", "topic": "Linear Programming", "question_description": "A set of n space stations need your help in building a radar system to track spaceships traveling between them. The ith space station is located in 3D space at coordinates (xi,yi,zi). The space stations never move. Each space station will have a radar of some power, say ri for the ith space station, where ri is to be determined.\n\nYou want to figure how powerful to make each space station's radar transmitter, so that whenever any spaceship travels in a straight line from one space station to another, it will always be in radar range of either the first space station (its origin) or the second space station (its destination). A radar with power ri is capable of tracking space ships anywhere in the sphere with radius ri centered at itself. Thus, a space ship is within radar range through its trip from space station i to space station j if every point along the line from (xi,yi,zi) to (xj,yj,zj) falls within either the sphere of radius ri centered at (xj,yi,zi) or the sphere of radius rj centered (xi,yi,zi). The cost of each radar transmitter is proportional to its power, and you want to minimize the total cost of all of the radar transmitters.\n\nYou are given all of the (x1,y1,z1),...,(xn,yn,zn) values, and your job is to choose values for ri,...,rn. Express this problem as a linear program.\n\n(a) Describe your variables for the linear program.\n\nSolution: ri = the power of the ith radar transmitter.\n\n(b) Write out the objective function.\nSolution: ri + r2 +...+ rn.\n\n(c) Between each pair of space stations, say station i and station j, we need one constraint (one linear inequality). What is it?\nSolution: ri + rj >= sqrt((xi-xj)^2 + (yi-yj)^2 + (zi-zj)^2).\n\n(d) What is the asymptotic running time of your algorithm, as a function of n and m and k?\nGive a short justification (a sentence or two).\nSolution: O(n^2). We need to compare each pair of space stations to create the constraints.\n\nComment: We gave no credit on part (d) for algorithms whose running time is exponential in n (even after memoization). For instance, algorithms that involved trying all subsets of A take at least 2^n time and thus got no credit. As another example, algorithms where the arguments to the function were sets typically fell into this category, as did dynamic programming approaches where the subproblems could include all possible subsets of A. (One way to avoid this was to have the argument(s) be an integer that holds the sum of the elements in the set, rather than using the set itself as the argument\u00e2\u20ac\u201dthis way the number of subproblems solved will be O(L) rather than O(2^n)).", "hint": "Think about the variables and constraints in the linear program and how they relate to the problem.", "subproblem": []}, {"question_id": "Fall2014_7", "topic": "Greedy Algorithms", "question_description": "Our spaceship's cook has baked a zero-gravity pizza and cut it into n slices, but the lack of gravity made him clumsy and the pizza wasn't evenly sliced: the n slices have size 51, 52,...,5,n. There are n hungry space travelers on board who each want to eat a slice of pizza. Suppose the ith traveler would be happy with any slice whose size is at least i. Give an efficient algorithm to determine whether it is possible to distribute the pizza slices so everyone is happy.\n\n(a) What algorithm design paradigm is most appropriate for this problem? Circle one of the following.\n\n(a) Divide-and-conquer\n\n(b) | Greedy algorithm\n\n(c) Dynamic programming\n(d) Linear programming\n(e) Reduce to network flow\n\n(f) None of the above\n\n"}]