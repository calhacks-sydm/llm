[{"question_id": "Fall2014_1", "topic": "Graphs and DFS", "question_description": "Circle TRUE or FALSE. Do not justify your answers on this problem.\n\n(a) | TRUE | or FALSE: If we perform DFS on an undirected graph, there are no cross edges.\n\n(b) | TRUE] or FALSE: If the DFS tree has no back edges, then there are no cycles in the graph.\n\n(c) | TRUE | or FALSE: Any tree with n vertices is guaranteed to have exactly n - 1 edges.\n\n(d) TRUE or| FALSE |: Suppose G is a directed graph G = (V,E), and define the undirected graph\nG' by G' = (V,E') where E' is the set of edges {u,v} such that (u,v) \u00e2\u02c6\u02c6 E or (v,u) \u00e2\u02c6\u02c6 E. Then,\nif G is not strongly connected, then it's guaranteed that G' is not connected.\n\n(e) TRUE or| FALSE |: If G is a strongly connected directed graph, then there is guaranteed to exist\na vertex such that deleting that vertex leaves you with a graph that is also strongly connected.\n\n(f) TRUE or| FALSE[ Suppose we have a directed acyclic graph (dag) G with at least n - 1 edges\nand where a topological sort yields the vertices v1,...,vn in that order. If we add the edge\n(vn, v1), then the resulting graph is guaranteed to be strongly connected.\n\n(g) TRUE or| FALSE}: Dijkstra's algorithm will always work correctly on any graph that has at\nmost two negative edges.\n\n(h) | TRUE] or FALSE: If an undirected graph with n vertices has k connected components, then it\nmust have at least n - k edges.\n\n(i) TRUE or| FALSE If a graph with integer lengths on the edges (some of them possibly neg-\native) has no negative cycle reachable from s, then Dijkstra's algorithm works correctly for\nfinding the length of the shortest path from s to every other vertex reachable from s.\n\n(j) TRUE or| FALSE} If we have a linear program where all of the coefficients and constants\nin every linear inequality are integers, then the optimum solution to this linear program must\nassign an integer value to every variable.\n\n(k) TRUE or |FALSE|: If we have an undirected graph G = (V,E) where |V| = |E|, then G is\nguaranteed to be a tree.\n\n(l) TRUE or| FALSE}: If G is a graph with positive lengths on the edges, and if all edge lengths\nare distinct, and if s,t are two vertices, then there is a unique shortest path from s to ft.", "answer": "a) FALSE\nb) TRUE\nc) TRUE\nd) TRUE\ne) FALSE\nf) FALSE\ng) TRUE\nh) TRUE\ni) TRUE\nj) TRUE\nk) FALSE\nl) FALSE", "hint": "Think about the properties of the graph and the type of edges that are present in the graph.", "subproblem": [{"title": "Undirected Graphs", "description": "Think about the properties of an undirected graph and the type of edges that are present in the graph."}, {"title": "Directed Graphs", "description": "Think about the properties of a directed graph and the type of edges that are present in the graph."}, {"title": "Trees", "description": "Think about the properties of a tree and the type of edges that are present in the graph."}], "simplifiedAns": "(a) FALSE: If we perform DFS on an undirected graph, there can be cross edges.\n\n(b) TRUE: If the DFS tree has no back edges, then there are no cycles in the graph.\n\n(c) TRUE: Any tree with n vertices is guaranteed to have exactly n - 1 edges.\n\n(d) TRUE: If G is not strongly connected, then it's guaranteed that G' is not connected.\n\n(e) FALSE: If G is a strongly connected directed graph, there is no guarantee that deleting any vertex will leave a graph that is also strongly connected.\n\n(f) FALSE: Adding the edge (vn, v1) to a directed acyclic graph (dag) does not guarantee that the resulting graph will be strongly connected.\n\n(g) TRUE: Dijkstra's algorithm will always work correctly on any graph that has at most two negative edges.\n\n(h) TRUE: If an undirected graph with n vertices has k connected components, then it must have at least n - k edges.\n\n(i) TRUE: If a graph with integer lengths on the edges has no negative cycle reachable from s, then Dijkstra's algorithm works correctly for finding the length of the shortest path from s to every other vertex reachable from s.\n\n(j) TRUE: If all coefficients and constants in every linear inequality of a linear program are integers, then the optimum solution must assign an integer value to every variable.\n\n(k) FALSE: An undirected graph with |V| = |E| is not guaranteed to be a tree.\n\n(l) FALSE: If G is a graph with positive lengths on the edges and all edge lengths are distinct, there can be multiple shortest paths from s to t."}, {"question_id": "Fall2014_2", "topic": "Divide-and-Conquer", "question_description": "Answer the following questions. No need to justify your answer. Use O(-) notation.\n\n(a) What is the asymptotic running time of decomposing a directed graph into strongly connected components, if the graph has n vertices and nlgn edges?\n\n(b) What is the asymptotic running time of Dijkstra's algorithm, on a graph with n vertices and m edges (assuming all edges have non-negative length), if we implement the priority queue with a binary heap?\n\n(c) What is the asymptotic running time of the Bellman-Ford algorithm, on a graph with n vertices and m edges?\n\n(d) What is the asymptotic solution to the recurrence F(n) = 3F(n/2) + 1gn?", "answer": "a) O(nlgn)\nb) O((n + m)lgn)\nc) O(nm)\nd) O(n^2)", "hint": "Break down the problem into smaller sub-problems and try to solve them one by one.", "subproblem": [{"title": "Question (a)", "description": "What is the asymptotic running time of decomposing a directed graph into strongly connected components, if the graph has n vertices and nlgn edges?"}, {"title": "Question (b)", "description": "What is the asymptotic running time of Dijkstra's algorithm, on a graph with n vertices and m edges (assuming all edges have non-negative length), if we implement the priority queue with a binary heap?"}, {"title": "Question (c)", "description": "What is the asymptotic running time of the Bellman-Ford algorithm, on a graph with n vertices and m edges?"}], "simplifiedAns": "(a) The asymptotic running time of decomposing a directed graph into strongly connected components is O(n + nlgn).\n\n(b) The asymptotic running time of Dijkstra's algorithm, on a graph with n vertices and m edges (assuming all edges have non-negative length), if we implement the priority queue with a binary heap is O((n + m)lgn).\n\n(c) The asymptotic running time of the Bellman-Ford algorithm, on a graph with n vertices and m edges is O(nm).\n\n(d) The asymptotic solution to the recurrence F(n) = 3F(n/2) + 1gn is O(n^log2(3)). This can be derived using the Master Theorem, where a = 3, b = 2, and f(n) = 1gn. Since log2(3) > 1, the solution is O(n^log2(3))."}, {"question_id": "Fall2014_3", "topic": "Algorithm Analysis", "question_description": "Answer the following questions, giving a short justification (a sentence or two).\n\n(a) Suppose we have already trained two classifiers. Classifier A is a k-nearest neighbors classifier with a fixed k = 25, using a linear search implementation (not a k-d tree). Classifier B is a random forest classifier with a fixed T = 25 (i.e., 25 decision trees), where each decision tree has depth at most 10. Now we want to know the running time to classify 100 test points. If the number of observations in the training set is very large, which classifier will be faster at this task? In other words, if we consider the asymptotic running time for this task as a function of n, which classifier will have an asymptotically faster running time?", "answer": "Classifier B. The running time of B is fixed regardless of n, whereas the running time of A is proportional to n.", "hint": "Think about the complexity of each classifier and how it relates to the size of the training set.", "subproblem": [{"title": "Analyze the complexity of Classifier A", "description": "Consider the complexity of Classifier A, which is a k-nearest neighbors classifier with a fixed k = 25, using a linear search implementation (not a k-d tree)."}, {"title": "Analyze the complexity of Classifier B", "description": "Consider the complexity of Classifier B, which is a random forest classifier with a fixed T = 25 (i.e., 25 decision trees), where each decision tree has depth at most 10."}, {"title": "Compare the complexities of Classifier A and B", "description": "Compare the complexities of Classifier A and B and determine which one will have an asymptotically faster running time."}], "simplifiedAns": "In this problem, we have two classifiers - Classifier A and Classifier B. Classifier A is a k-nearest neighbors classifier with a fixed k value of 25, while Classifier B is a random forest classifier with 25 decision trees, each with a maximum depth of 10.\n\nWe want to know which classifier will be faster at classifying 100 test points, assuming we have a very large training set. To determine this, we need to consider the asymptotic running time of each classifier as a function of the number of observations in the training set, denoted as n.\n\nClassifier A, which uses a linear search implementation, will have a running time that is proportional to n. This means that as the number of observations in the training set increases, the running time of Classifier A will also increase.\n\nOn the other hand, Classifier B has a fixed running time regardless of the number of observations in the training set. This means that no matter how large the training set is, Classifier B will always take the same amount of time to classify the test points.\n\nTo understand this concept, we can think of Classifier A as a person searching for a specific book in a library. The more books there are in the library (representing the number of observations in the training set), the longer it will take for the person to find the book they are looking for.\n\nIn contrast, Classifier B can be compared to a group of people working together to find the same book. Each person in the group represents a decision tree in the random forest classifier. No matter how many books there are in the library, the group of people will always take the same amount of time to find the book, as they can divide the work among themselves.\n\nTherefore, in terms of asymptotic running time, Classifier B will be faster at classifying 100 test points when the training set is very large."}, {"question_id": "Fall2014_4", "topic": "Dynamic Programming", "question_description": "We have a directed graph G = (V,E) with n vertices and m edges and integer lengths on all the edges. Only k of the edges have negative lengths; all the others have non-negative lengths. There are no negative cycles.\n\nYour friend has a clever idea for computing the length of the shortest path from a vertex s to a vertex t. He will construct a new graph G' whose vertices are the endpoints of the negative edges of G, together with s and t. Each edge (u,v) in G' represents the length of the shortest path from u to v in G without using any negative-length edge. He'll use Dijkstra's algorithm to compute each of these lengths. Then, he'll add in all of the negative edges to G', and run Bellman-Ford on the result.\n\nWhat is the asymptotic running time of your friend's algorithm, as a function of n and m and k? Give a short justification (a sentence or two).", "answer": "O(k(n + m)lgn + 4). We do Dijkstra's algorithm 2k times, once for each endpoint of a negative edge, and that takes O((n + m)lgn) time per endpoint; then Bellman-Ford takes O(k^2) time.", "hint": "Think about the time complexity of each step of your friend's algorithm and combine them to get the total time complexity.", "subproblem": [{"title": "Dijkstra's Algorithm", "description": "Dijkstra's algorithm is used to find the shortest path from a given source vertex to all other vertices in a graph. It has a time complexity of O((n + m)lgn)."}, {"title": "Bellman-Ford Algorithm", "description": "Bellman-Ford algorithm is used to find the shortest paths from a given source vertex to all other vertices in a graph. It has a time complexity of O(k^2)."}, {"title": "Combining Time Complexities", "description": "Combine the time complexities of Dijkstra's and Bellman-Ford algorithms to get the total time complexity of your friend's algorithm."}], "simplifiedAns": "Your friend's algorithm aims to find the shortest path from a starting vertex to a target vertex in a directed graph with both positive and negative edge lengths. To do this, he constructs a new graph G' by considering only the endpoints of the negative edges in the original graph G, along with the starting and target vertices. He then uses Dijkstra's algorithm to find the shortest path from each endpoint of a negative edge to all other vertices in G without using any negative-length edge. \n\nThe running time of Dijkstra's algorithm is O((n + m)logn) per endpoint, where n is the number of vertices and m is the number of edges in G. Since there are k negative edges, your friend performs Dijkstra's algorithm 2k times, once for each endpoint of a negative edge. Therefore, the total running time for Dijkstra's algorithm is O(k(n + m)logn).\n\nAfter constructing G', your friend adds all the negative edges from G to G' and runs Bellman-Ford algorithm on G'. The running time of Bellman-Ford algorithm is O(k^2), where k is the number of negative edges. \n\nTherefore, the overall running time of your friend's algorithm is O(k(n + m)logn + k^2)."}, {"question_id": "Fall2014_5", "topic": "Divide-and-Conquer", "question_description": "Given two sorted lists of size m and n, we want to find the kth smallest element in the concatenation of the two lists. Fill in the blanks below so we get an algorithm whose running time is O(lgm + Ign). Assume k < m and k < n.\n\nFind_kth_elem(A[1..m], B[1..n],k):\n1. Let x:=A[|k/2}] and y := B[[k/2]].\n2. If x==y:\n\n3. Return |x\n\n4. If x>y:\n5. Return Find_kth_elem(A|| 1 |.) |&/2] |], Bl] [k/2] + 1]..,&]], | [k/2] )\n6. If x<y:\n7. Return Find_kth_elem(A|| |k/2| + 1}..[&|], B[L1 |.) [&/2] J], | [k/21)\n\nNow, answer the following question. Which algorithm design paradigm does this algorithm best represent?\n\n1. Divide-and-conquer\n\n2. Greedy algorithm\n\n3. Dynamic programming\n4. Linear programming\n\n5. Reduce to network flow\n\n6. None of the above", "answer": "1. Divide-and-conquer", "hint": "Think about how the problem is being broken down into smaller subproblems and how the solution is being constructed from the solutions of the subproblems.", "subproblem": [{"title": "Divide the problem into two subproblems", "description": "Divide the problem into two subproblems by comparing the kth element of the two sorted lists and recursively calling the function on the smaller subproblem."}, {"title": "Find the kth element", "description": "Find the kth element by comparing the kth element of the two sorted lists and returning the smaller one."}, {"title": "Base case", "description": "The base case is when the kth element of the two sorted lists is equal, in which case the kth element is returned."}], "simplifiedAns": "The algorithm provided represents the divide-and-conquer design paradigm. \n\nIn this problem, we are given two sorted lists, A and B, and we want to find the kth smallest element in the concatenation of the two lists. \n\nThe algorithm divides the problem into smaller subproblems by selecting the middle elements, x and y, from the two lists. It then compares x and y to determine the next step. \n\nIf x is equal to y, it means we have found the kth smallest element and we can return it. \n\nIf x is greater than y, it means the kth smallest element must be in the first half of list A or the second half of list B. We recursively call the algorithm on these sublists.\n\nIf x is less than y, it means the kth smallest element must be in the second half of list A or the first half of list B. Again, we recursively call the algorithm on these sublists.\n\nBy dividing the problem into smaller subproblems and solving them recursively, the algorithm efficiently finds the kth smallest element in the concatenation of the two lists. This is a characteristic of the divide-and-conquer design paradigm."}, {"question_id": "Fall2014_6", "topic": "Linear Programming", "question_description": "A set of n space stations need your help in building a radar system to track spaceships traveling between them. The ith space station is located in 3D space at coordinates (xi,yi,zi). The space stations never move. Each space station will have a radar of some power, say ri for the ith space station, where ri is to be determined.\n\nYou want to figure how powerful to make each space station's radar transmitter, so that whenever any spaceship travels in a straight line from one space station to another, it will always be in radar range of either the first space station (its origin) or the second space station (its destination). A radar with power ri is capable of tracking space ships anywhere in the sphere with radius ri centered at itself. Thus, a space ship is within radar range through its trip from space station i to space station j if every point along the line from (xi,yi,zi) to (xj,yj,zj) falls within either the sphere of radius ri centered at (xj,yi,zi) or the sphere of radius rj centered (xi,yi,zi). The cost of each radar transmitter is proportional to its power, and you want to minimize the total cost of all of the radar transmitters.\n\nYou are given all of the (x1,y1,z1),...,(xn,yn,zn) values, and your job is to choose values for ri,...,rn. Express this problem as a linear program.\n\n(a) Describe your variables for the linear program.\n\nSolution: ri = the power of the ith radar transmitter.\n\n(b) Write out the objective function.\nSolution: ri + r2 +...+ rn.\n\n(c) Between each pair of space stations, say station i and station j, we need one constraint (one linear inequality). What is it?\nSolution: ri + rj >= sqrt((xi-xj)^2 + (yi-yj)^2 + (zi-zj)^2).\n\n(d) What is the asymptotic running time of your algorithm, as a function of n and m and k?\nGive a short justification (a sentence or two).\nSolution: O(n^2). We need to compare each pair of space stations to create the constraints.\n\nComment: We gave no credit on part (d) for algorithms whose running time is exponential in n (even after memoization). For instance, algorithms that involved trying all subsets of A take at least 2^n time and thus got no credit. As another example, algorithms where the arguments to the function were sets typically fell into this category, as did dynamic programming approaches where the subproblems could include all possible subsets of A. (One way to avoid this was to have the argument(s) be an integer that holds the sum of the elements in the set, rather than using the set itself as the argument\u00e2\u20ac\u201dthis way the number of subproblems solved will be O(L) rather than O(2^n)).", "hint": "Think about the variables and constraints in the linear program and how they relate to the problem.", "subproblem": []}, {"question_id": "Fall2014_7", "topic": "Greedy Algorithms", "question_description": "Our spaceship's cook has baked a zero-gravity pizza and cut it into n slices, but the lack of gravity made him clumsy and the pizza wasn't evenly sliced: the n slices have size 51, 52,...,5,n. There are n hungry space travelers on board who each want to eat a slice of pizza. Suppose the ith traveler would be happy with any slice whose size is at least i. Give an efficient algorithm to determine whether it is possible to distribute the pizza slices so everyone is happy.\n\n(a) What algorithm design paradigm is most appropriate for this problem? Circle one of the following.\n\n(a) Divide-and-conquer\n\n(b) | Greedy algorithm\n\n(c) Dynamic programming\n(d) Linear programming\n(e) Reduce to network flow\n\n(f) None of the above\n\n"}]