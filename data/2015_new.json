[{"question_id": "Fall_2015_1", "topic": "Strongly Connected Components", "question_description": "For the directed graph below, list the strongly connected components in the order in which they are output by the strongly connected components algorithm.", "answer": "{F, G}, {J}, {B, C, D, E, H}, {A}", "hint": "Start by breaking the graph into its individual components and then look for the strongly connected components within each component.", "subproblem": [{"title": "Break the graph into its individual components", "description": "Look for the nodes that are connected to each other and group them together."}, {"title": "Find the strongly connected components within each component", "description": "Look for the nodes that are connected to each other in both directions and group them together."}], "simplifiedAns": "Sure! Let's imagine that we have a classroom with students and their friendships represented by a directed graph. In this graph, each student is represented by a letter, and the directed edges represent friendships.\n\nNow, the problem asks us to find the strongly connected components in this graph using the strongly connected components algorithm. A strongly connected component is a group of vertices (students) where there is a directed path from any vertex to any other vertex within the group.\n\nTo solve this problem, we can follow these steps:\n\n1. Start with any vertex (student) in the graph.\n2. Explore all the vertices reachable from this vertex using a depth-first search (DFS) algorithm.\n3. Once we have explored all the reachable vertices, we have found a strongly connected component.\n4. Mark all the vertices in this component as visited.\n5. Repeat steps 1-4 until all vertices have been visited.\n\nNow, let's apply this algorithm to the given directed graph:\n\n1. We start with vertex F. We can reach vertex G from F, so the first strongly connected component is {F, G}.\n2. Next, we move to vertex J. Since J has no outgoing edges, it forms a strongly connected component on its own: {J}.\n3. Moving on, we choose vertex B. From B, we can reach C, D, E, and H. So, the next strongly connected component is {B, C, D, E, H}.\n4. Finally, we consider vertex A. Since A has no outgoing edges, it forms a strongly connected component on its own: {A}.\n\nTherefore, the strongly connected components in the given directed graph, in the order output by the algorithm, are: {F, G}, {J}, {B, C, D, E, H}, and {A}.\n\nIn the context of our classroom analogy, the strongly connected components represent groups of friends who are tightly connected to each other. For example, {F, G} could represent two friends who always hang out together, {J} could represent a student who prefers to be alone, {B, C, D, E, H} could represent a group of friends who are all connected to each other, and {A} could represent a student who doesn't have any friends in the classroom.\n\nI hope this explanation helps you understand the solution to the problem!"}, {"question_id": "Fall_2015_2", "topic": "Graphs and DFS", "question_description": "Draw the state of the union-find data structure (union operations using rank, but without path compression) at the end of the 7th iteration of Kruskal's algorithm on the graph shown below.", "answer": "There's a couple of solutions, depending on tie-breaking in deciding the parent during the union process. Here's one: () G", "hint": "Think about how the union-find data structure works and how it changes with each iteration of Kruskal's algorithm.", "subproblem": [{"title": "Understand the union-find data structure", "description": "Learn how the union-find data structure works and how it is used to solve Kruskal's algorithm."}, {"title": "Trace the 7th iteration of Kruskal's algorithm", "description": "Trace the 7th iteration of Kruskal's algorithm on the given graph and identify the changes in the union-find data structure."}], "simplifiedAns": "In Kruskal's algorithm, we use a union-find data structure to keep track of the connected components in a graph. This data structure helps us determine if two vertices are already connected or not.\n\nIn this problem, we are asked to draw the state of the union-find data structure at the end of the 7th iteration of Kruskal's algorithm on a given graph. The graph is not provided, but we can assume it has several vertices and edges.\n\nTo solve this problem, we need to understand how the union-find data structure works. It consists of a set of disjoint sets, where each set represents a connected component. Initially, each vertex is in its own set.\n\nDuring the iterations of Kruskal's algorithm, we consider the edges in ascending order of their weights. For each edge, we check if its two vertices are already in the same set or not. If they are not, we merge the sets by making one vertex the parent of the other.\n\nIn this specific case, after 7 iterations, we have performed 7 union operations. The state of the union-find data structure at this point can be represented as follows:\n\n(A, B, C, D, E, F, G) - Each letter represents a vertex, and the parentheses indicate the sets they belong to.\n\nNow, let's assume that during the union process, we always choose the parent based on the rank (the number of vertices in the set). In case of a tie, we can choose any vertex as the parent.\n\nAt the end of the 7th iteration, the union-find data structure will look like this:\n\n(A, B, C, D, E, F(G)) - Here, F and G were in separate sets, but now they are merged. The parent of this set is G because it has a higher rank than F.\n\nTo understand this visually, imagine each vertex as a person, and the sets as groups of friends. Initially, everyone is in their own group. As we iterate through the edges, we start connecting these groups by making one person the leader of the other. In this case, after 7 iterations, F and G become friends, and G becomes the leader of their combined group.\n\nI hope this explanation helps you understand the solution to the problem. Let me know if you have any further questions!"}, {"question_id": "Fall_2015_3", "topic": "Graphs and DFS", "question_description": "In the lecture, we've learnt an approximation algorithm for traveling salesman problem based on computing MST and a depth first traversal. Suppose we run this approximation algorithm for Traveling Salesman Problem on the following graph. The algorithm will return different tours based on the choices it makes during its depth-first traversal stage.", "answer": "The algorithm will return different tours based on the choices it makes during its depth-first traversal stage.", "hint": "Think about the different choices the algorithm can make during the depth-first traversal stage and how it affects the tour it returns.", "subproblem": [{"title": "Compute MST", "description": "Compute the minimum spanning tree of the given graph."}, {"title": "Depth-first traversal", "description": "Perform a depth-first traversal on the MST to generate a tour."}], "simplifiedAns": "The Traveling Salesman Problem is a problem where a salesman needs to visit a set of cities and return to the starting city, while minimizing the total distance traveled. \n\nThe approximation algorithm we learned in the lecture uses two main steps: computing the Minimum Spanning Tree (MST) of the graph and performing a depth-first traversal. \n\nFirst, the algorithm constructs the MST of the graph. The MST is a tree that connects all the cities with the minimum total edge weight. It ensures that all cities are reachable and avoids unnecessary detours. \n\nNext, the algorithm performs a depth-first traversal starting from the starting city. It explores all possible paths by visiting neighboring cities until it reaches a dead end. It then backtracks and explores other paths until it has visited all cities. \n\nDuring the depth-first traversal, the algorithm makes choices on which neighboring city to visit next. These choices can vary depending on the order in which the algorithm encounters the cities. As a result, the algorithm can return different tours based on these choices. \n\nTo understand this concept, imagine you are exploring a maze. You start at a certain point and have multiple paths to choose from. Each time you reach a junction, you randomly choose a path to follow. The choices you make will determine the route you take and the places you visit. Similarly, the algorithm's choices during the depth-first traversal stage determine the tour it returns for the Traveling Salesman Problem. \n\nIn conclusion, the approximation algorithm for the Traveling Salesman Problem uses a combination of computing the MST and performing a depth-first traversal. The algorithm returns different tours based on the choices it makes during the depth-first traversal stage, similar to how different routes can be taken in a maze depending on the choices made at each junction."}, {"question_id": "Fall_2015_4", "topic": "Graphs and DFS", "question_description": "Consider the following graph on 7 vertices.", "answer": "The order in which the quantities reach their final correct values is {Dist(6), Dist(3), Dist(5), Dist(7)}.", "hint": "Apply Dijkstra's algorithm and Floyd-Warshall algorithm to compute the shortest paths in the graph.", "subproblem": [{"problem_order": "1", "description": "Execute Dijkstra's algorithm to compute distances from the vertex 1."}, {"problem_order": "2", "description": "Execute the Floyd-Warshall algorithm to compute pairwise distances."}, {"problem_order": "3", "description": "Determine the order in which the quantities reach their final correct values."}]}, {"question_id": "Fall_2015_5", "topic": "Divide-and-Conquer", "question_description": "The following algebraic identities can be used to design a divide-and-conquer algorithm for multiplying n-bit numbers.", "answer": "The recurrence relation for running time T(n) of the algorithm is T(n) = 6T(n/3) + O(n). The running time of the algorithm is T(n) = O(n^log3(6)).", "hint": "Consider the algebraic identities provided and derive the recurrence relation and running time of the algorithm.", "subproblem": [{"problem_order": "1", "description": "Write the recurrence relation for running time T(n) of the algorithm."}, {"problem_order": "2", "description": "Determine the running time of the algorithm."}]}, {"question_id": "Fall_2015_6", "topic": "Reductions, Bipartite Matching", "question_description": "Assume A and B are search problems, and A reduces to B in polynomial time. In each part you will be given a fact about one of the problems. Determine what, if anything, this allows you to determine about the other problem. Answer each part in one sentence.", "answer": "In part (a), nothing can be determined about A or B. In part (b), it can be determined that A is in P if B is in P. In part (c), it can be determined that B is NP-complete if A is NP-hard. In part (d), nothing can be determined about A or B.", "hint": "Consider the definitions of NP, NP-hard, and NP-complete to determine the relationships between A and B.", "subproblem": [{"problem_order": "1", "description": "Determine what, if anything, can be determined about A or B based on the given fact."}]}, {"question_id": "Fall_2015_7", "topic": "Reductions, Bipartite Matching", "question_description": "After years of research, Horizon Wireless released an encryption algorithm E that encrypts an n-bit message in time O(n^k). Show that if P = NP then this encryption algorithm can be broken in polynomial time. More precisely, argue that if P = NP, then the following decryption problem can be solved in polynomial time.", "answer": "If P = NP, then the decryption problem can be solved in polynomial time because the encryption algorithm can be verified in polynomial time.", "hint": "Consider the definition of P and NP to determine the implications of P = NP on the decryption problem.", "subproblem": [{"problem_order": "1", "description": "Explain the implications of P = NP on the decryption problem."}]}, {"question_id": "Fall_2015_8", "topic": "Zero-Sum Games", "question_description": "Alice and Bob are playing a zero-sum game whose payoff matrix is shown below. The ij entry of the matrix shows the payoff that Alice receives if she plays strategy i and Bob plays strategy j. Alice is the row player and is trying to maximize her payoff.", "answer": "The optimal solution is for Alice to play strategy A with a value of 4.", "hint": "Analyze the payoff matrix to determine the optimal strategy for Alice.", "subproblem": [{"problem_order": "1", "description": "Analyze the payoff matrix to determine the optimal strategy for Alice."}]}, {"question_id": "Fall_2015_9", "topic": "NP-Completeness", "question_description": "Which of the following are NP-search problems? Justify your answers.", "answer": "In part (a), the problem is in P and a polynomial-time algorithm exists. In part (b), the problem is NP-hard. ", "hint": "Consider the definitions of NP and NP-hard to determine if the problems are NP-search problems.", "subproblem": [{"problem_order": "1", "description": "Determine if the given problem is an NP-search problem."}]}, {"question_id": "Fall_2015_10", "topic": "Graphs and DFS", "question_description": "The diameter d of an undirected graph G = (V,E) with unit lengths, is defined to be the maximum distance between any two vertices, i.e. d = max d(u,v), where d(u,v) is the length of the shortest path between u and v.", "answer": "The algorithm has a time complexity of O(|V| + |E|) and provides a 2-approximation for computing the diameter.", "hint": "Design an algorithm that provides a 2-approximation for computing the diameter of the graph.", "subproblem": [{"problem_order": "1", "description": "Design an algorithm that provides a 2-approximation for computing the diameter of the graph."}]}, {"question_id": "Fall_2015_11", "topic": "Graphs and DFS", "question_description": "Horizon Wireless is building a 5G network. The company has a set V of wireless towers; the distance d(i,j) between any two of them is known, and each tower is capable of transmitting to other towers within a distance r. To make this network fault-tolerant, Horizon wants to assign each tower v in V to two other backup towers, so that if v is about to fail, it can transmit its data to them. Due to storage constraints, each tower can only serve as a backup for up to three other towers.", "answer": "The algorithm reduces the problem to max flow and determines if there is a flow with value at least 2|A|, where A is the set of active towers.", "hint": "Reduce the problem to max flow and determine if there is a flow with a certain value.", "subproblem": [{"problem_order": "1", "description": "Reduce the problem to max flow and determine if there is a flow with a certain value."}]}, {"question_id": "Fall_2015_12", "topic": "NP-Completeness", "question_description": "Prove that the following problems are NP-hard.", "answer": "In part (a), DIRECTED RUDRATA CYCLE reduces to RUDRATA CYCLE. In part (b), CALIFORNIAN CYCLE reduces to DIRECTED RUDRATA CYCLE. In part (c), 4-SAT reduces to 3-SAT.", "hint": "Use reduction to prove that the given problems are NP-hard.", "subproblem": [{"problem_order": "1", "description": "Use reduction to prove that the given problem is NP-hard."}]}, {"question_id": "Fall_2015_13", "topic": "NP-Completeness", "question_description": "The 3-SET COVER problem is a special case of the MINIMUM SET COVER PROBLEM where every element appears in at most 3 sets. The formal definition of the problem is as follows.", "answer": "In part (a), we reduce VERTEX COVER to 3-SET COVER. In part (b), we model the problem using a linear program. In part (c), LPOpt cannot be greater than Opt. In part (d), LPOpt can be less than OPT. In part (e), the algorithm yields a 3-approximation for the problem.", "hint": "Use reduction and linear programming to analyze the 3-SET COVER problem.", "subproblem": [{"problem_order": "1", "description": "Use reduction to prove that 3-SET COVER is NP-hard."}, {"problem_order": "2", "description": "Model the 3-SET COVER problem using a linear program."}, {"problem_order": "3", "description": "Justify that LPOpt cannot be greater than Opt."}, {"problem_order": "4", "description": "Justify that LPOpt can be less than OPT."}, {"problem_order": "5", "description": "Prove that the algorithm yields a 3-approximation for the problem."}]}]